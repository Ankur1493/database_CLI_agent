import fs from "fs/promises";
import { OpenAI } from "openai";
import { getParsedData } from "../helperFunctions";
import { API_PROMPT, COMPONENT_PROMPT } from "../prompts";

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

// Action: Generate API routes
export async function generateAPIRoute(dir: string, userQuery?: string) {
  console.log("Generating API routes...");

  // Get parsed data from data.json
  const parsedData = await getParsedData(dir);

  if (Object.keys(parsedData).length === 0) {
    console.log(
      "No data found. Please run 'imports' command first to extract data."
    );
    return "No data found - please run extract-data first";
  }

  // Read the schema file
  let schemaContent = "";
  try {
    schemaContent = await fs.readFile(`${dir}/src/drizzle/schema.ts`, "utf-8");
  } catch (error) {
    console.log("Error reading schema file:", error);
    return "Error reading schema file - please run generate-schema first";
  }

  // Generate API route using GPT with user query and schema
  if (userQuery) {
    return await generateAPIRouteWithGPT(
      dir,
      userQuery,
      schemaContent,
      parsedData
    );
  } else {
    console.log(
      "Please provide a query to generate API routes for specific tables"
    );
    return "No user query provided for API generation";
  }
}

async function generateAPIRouteWithGPT(
  dir: string,
  userQuery: string,
  schemaContent: string,
  parsedData: Record<string, { data: any[]; sourceFiles: string[] }>
) {
  console.log(`Generating API route for query: "${userQuery}" using GPT...`);

  const availableTables = Object.keys(parsedData);

  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        {
          role: "system",
          content:
            "You are a Next.js App Router API expert who generates clean, production-ready API routes using Drizzle ORM. You analyze user queries and intelligently select the most appropriate database table from the provided schema.",
        },
        {
          role: "user",
          content: API_PROMPT(userQuery, availableTables, schemaContent),
        },
      ],
    });

    const apiRouteContent = response.choices[0]?.message?.content ?? "";

    if (!apiRouteContent.trim()) {
      console.log("‚ùå Error: No content generated by GPT");
      console.log(
        "Please try again with a different query or check your OpenAI API key."
      );
      return;
    }
    console.log({ apiRouteContent });

    // Check if the response contains error messages from GPT
    const errorKeywords = [
      "can't do that",
      "table not found",
      "multiple tables",
      "not in the schema",
      "cannot",
      "unable to",
    ];

    const hasError = errorKeywords.some((keyword) =>
      apiRouteContent.toLowerCase().includes(keyword)
    );

    if (hasError) {
      console.log("‚ùå Error: " + apiRouteContent.trim());
      return;
    }

    // Extract route name and table name from GPT response
    const routeNameMatch = apiRouteContent.match(/^ROUTE_NAME:\s*([^\n]+)/);
    const tableNameMatch = apiRouteContent.match(/^TABLE_NAME:\s*([^\n]+)/m);

    if (!routeNameMatch) {
      console.log("‚ùå Error: No route name found in GPT response");
      console.log("Expected format: ROUTE_NAME: [route-name]");
      return;
    }

    if (!tableNameMatch) {
      console.log("‚ùå Error: No table name found in GPT response");
      console.log("Expected format: TABLE_NAME: [table-name]");
      return;
    }

    const routeName = routeNameMatch[1]?.trim() ?? "";
    const tableName = tableNameMatch[1]?.trim() ?? "";

    if (!routeName) {
      console.log("‚ùå Error: Empty route name received from GPT");
      return;
    }

    if (!tableName) {
      console.log("‚ùå Error: Empty table name received from GPT");
      return;
    }

    // Validate route name format (should be kebab-case)
    if (!/^[a-z0-9-]+$/.test(routeName)) {
      console.log("‚ùå Error: Invalid route name format");
      console.log("Route name should be kebab-case (e.g., 'recently-played')");
      return;
    }

    // Validate table name exists in available tables
    if (!availableTables.includes(tableName)) {
      console.log(
        `‚ùå Error: Table name "${tableName}" not found in available tables`
      );
      console.log(`Available tables: ${availableTables.join(", ")}`);
      return;
    }

    console.log(`üìã GPT provided table name: ${tableName}`);

    const codeContent = apiRouteContent
      .replace(/^ROUTE_NAME:\s*[^\n]+\n/, "")
      .replace(/^TABLE_NAME:\s*[^\n]+\n/m, "")
      .trim();

    // Create the API routes directory structure
    const apiDir = `${dir}/src/app/api/${routeName}`;
    await fs.mkdir(apiDir, { recursive: true });

    // Write the API route file
    await fs.writeFile(`${apiDir}/route.ts`, codeContent, "utf-8");
    console.log(
      `‚úÖ API route created successfully: src/app/api/${routeName}/route.ts`
    );
    console.log(`üîó Route path: /api/${routeName}`);
    console.log(`üìù Generated from query: "${userQuery}"`);

    // Store API route details in data.json for tracking
    try {
      const dataFilePath = `${dir}/data.json`;
      let existingData: any = {};

      // Read existing data.json if it exists
      try {
        const existingContent = await fs.readFile(dataFilePath, "utf-8");
        existingData = JSON.parse(existingContent);
      } catch (readError) {
        // If file doesn't exist or is invalid, start with empty object
        console.log("Creating new data.json file for API route tracking");
      }

      // Initialize apiRoutes array if it doesn't exist
      if (!existingData.apiRoutes) {
        existingData.apiRoutes = [];
      }

      // Add the new API route details
      const apiRouteDetails = {
        routeName: routeName,
        filePath: `src/app/api/${routeName}/route.ts`,
        routePath: `/api/${routeName}`,
        generatedFrom: userQuery,
        createdAt: new Date().toISOString(),
        tableUsed: tableName,
      };

      existingData.apiRoutes.push(apiRouteDetails);

      // Write updated data back to data.json
      await fs.writeFile(
        dataFilePath,
        JSON.stringify(existingData, null, 2),
        "utf-8"
      );
      console.log(`üìã API route details stored in data.json`);
      console.log(
        `üìä Total API routes tracked: ${existingData.apiRoutes.length}`
      );
      generateFrontendFetchCalls(
        dir,
        apiRouteDetails.routePath,
        apiRouteDetails.tableUsed,
        parsedData
      );

      return `API route created successfully: /api/${routeName} for table ${tableName}`;
    } catch (trackingError) {
      console.log(
        "‚ö†Ô∏è Warning: Could not store API route details in data.json:",
        trackingError
      );
      return `API route created successfully: /api/${routeName} for table ${tableName} (tracking failed)`;
    }
  } catch (error) {
    console.log("‚ùå Error generating API route with GPT:", error);
    console.log("Please check your OpenAI API key and try again.");
    return `Error generating API route: ${error}`;
  }
}

async function generateFrontendFetchCalls(
  dir: string,
  routePath: string,
  tableName: string,
  parsedData: Record<string, { data: any[]; sourceFiles: string[] }>
) {
  console.log(`Generating frontend fetch calls for ${tableName}...`);

  // Find the source files for this table
  const tableInfo = parsedData[tableName];
  if (!tableInfo) {
    console.log(`‚ùå No data found for table: ${tableName}`);
    return;
  }

  const sourceFiles = tableInfo.sourceFiles;
  console.log(`üìÅ Source files: ${sourceFiles.join(", ")}`);

  // Update all source files that contain this constant
  for (const sourceFile of sourceFiles) {
    console.log(`üîÑ Updating ${sourceFile} with GPT...`);

    try {
      // Read the source file
      const fileContent = await fs.readFile(sourceFile, "utf-8");

      // Check if the constant name exists in the file
      if (!fileContent.includes(tableName)) {
        console.log(
          `‚ùå Constant name "${tableName}" not found in ${sourceFile}`
        );
        continue;
      }

      // Use GPT to update the file
      const updatedCode = await generateUpdatedComponentCodeWithGPT(
        fileContent,
        tableName,
        routePath,
        sourceFile
      );

      if (updatedCode) {
        // Write the updated file
        await fs.writeFile(sourceFile, updatedCode, "utf-8");
        console.log(
          `‚úÖ Updated ${sourceFile} with fetch calls for ${tableName}`
        );
      } else {
        console.log(
          `‚ùå Failed to update ${sourceFile} - no content returned from GPT`
        );
      }
    } catch (error) {
      console.log(`‚ùå Error updating frontend file ${sourceFile}: ${error}`);
    }
  }
}

async function generateUpdatedComponentCodeWithGPT(
  fileContent: string,
  tableName: string,
  routePath: string,
  sourceFile: string
): Promise<string> {
  console.log(`ü§ñ Using GPT to update ${sourceFile} for ${tableName}...`);

  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        {
          role: "system",
          content:
            "You are a React/Next.js expert who updates component files to use dynamic data fetching instead of static constants. You return only the complete updated file content without any explanations.",
        },
        {
          role: "user",
          content: COMPONENT_PROMPT(tableName, routePath, fileContent),
        },
      ],
    });

    const updatedContent = response.choices[0]?.message?.content ?? "";

    if (!updatedContent.trim()) {
      console.log(`‚ùå No content returned from GPT for ${sourceFile}`);
      return fileContent; // Return original content if GPT fails
    }

    console.log(`‚úÖ GPT successfully updated ${sourceFile}`);
    return updatedContent;
  } catch (error) {
    console.log(`‚ùå Error calling GPT for ${sourceFile}:`, error);
    return fileContent; // Return original content if GPT fails
  }
}
